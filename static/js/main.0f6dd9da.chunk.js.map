{"version":3,"sources":["../../src/types.ts","../../src/store.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/utils.ts","../../src/selectors.ts","../../src/icons.tsx","../../src/Layout.tsx","../../src/contstans.ts","../../src/index.tsx","App.js","index.js"],"names":["TABS","SORT","Columns","initialState","tab","sort","column","search","pairs","pairsOrder","dispatch","store","createContext","StateProvider","children","Provider","useReducer","action","pairsClone","state","updates","Object","updatedKey","l","o","h","c","v","parseFloat","Error","value","Symbol","iterator","asyncIterator","pairChange","pair","keyBy","array","key","x","getBinanceData","jsonFetch","request","body","recover","result","e","then","fetch","response","console","data","type","payload","filteredPairsSelector","memoize","filter","tabСondition","searchCondition","pairsSelector","filteredPairs","clone","a","b","star","xmlns","viewBox","fill","d","arrowsDefault","arrowsAsc","opacity","id","x1","y1","x2","y2","gradientUnits","offset","arrowsDsc","Layout","title","height","width","context","useContext","sortedPairs","useEffect","url","WebSocket","ws","JSON","evt","connectWebSocket","updateValue","name","arrowIcon","style","React","className","styles","onClick","placeholder","onChange","checked","htmlFor","table","href","itemCount","length","itemSize","innerElementType","index","q","props","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.0f6dd9da.chunk.js","sourcesContent":["export enum TABS {\n  FAV = 'FAV',\n  BNB = 'BNB',\n  BTC = 'BTC',\n  ALTS = 'ALTS',\n  FIAT = 'USDⓈ'\n}\n\nexport enum SORT {\n  PairASC = 'PairASC',\n  PairDSC = 'PairDSC',\n  PriceASC = 'PriceASC',\n  PriceDSC = 'PriceDSC',\n  ChangeASC = 'ChangeASC',\n  ChangeDSC = 'ChangeDSC',\n  VolumeASC = 'VolumeASC',\n  VolumeDSC = 'VolumeDSC'\n}\n\nexport enum Columns {\n  Change = 'Change',\n  Volume = 'Volume'\n}\n\nexport interface BinanceWidgetProps {\n  title?: string;\n  width?: number;\n  height?: number;\n  defaultTab?: TABS;\n  defaultSort?: SORT;\n  thirdCol?: Columns;\n}\n/**\n * Pair interface\n * represent a crypto pairs from Binance API, description of parameters: \n * * s - Pair name = base + quote asset. Used as key \n * * b - base asset\n * * q - quote asset\n * * qa - symbol\n * * ts - timestamp\n * * an - base asset whole name\n * * qn - quote asset whole name\n * * o -open price\n * * h -high price\n * * l -low price\n * * c -latest price\n * * pm - parent market\n * * pn - category of the parent market\n * @export\n * @interface Pair\n */\nexport interface Pair {\n  s: string, // Pair name = base + quote asset. Used as key \n  st: string,\n  b: string, // base asset\n  q: string, // quote asset\n  ba: string,\n  qa: string, // symbol\n  i: number,\n  ts: number, // timestamp\n  an: string, // base asset whole name\n  qn: string, // quote asset whole name\n  o: number, // open price\n  h: number, // high price\n  l: number, // low price\n  c: number, // latest price\n  v: number,\n  qv: number,\n  y: number,\n  as: number,\n  pm: string, // parent market\n  pn: string, // category of the parent market\n  cs: number,\n  etf: boolean\n}\n\nexport interface PairAssocArray {\n  [s: string]: Pair\n}\n\nexport interface storeShape {\n  tab: TABS;\n  sort: SORT;\n  column: Columns;\n  search: string;\n  pairs: PairAssocArray;\n  pairsOrder: string[];\n  dispatch?: any;\n}\n\nexport type childProps = {\n  children: React.ReactNode\n};","// store.js\nimport React, { createContext } from 'react';\nimport { useReducer } from 'reinspect';\nimport { storeShape, TABS, SORT, Columns, childProps } from './types';\n\nconst initialState: storeShape = {\n  tab: TABS.BTC,\n  sort: SORT.PairASC,\n  column: Columns.Change,\n  search: '',\n  pairs: {},\n  pairsOrder: [],\n  dispatch: function (action: any) {\n    return undefined;\n  }\n};\n\nexport const store = createContext(initialState);\n\nexport const StateProvider: React.FC = ({ children }: childProps) => {\n  const { Provider } = store;\n  const [state, dispatch] = useReducer(\n    (state: storeShape, action: any) => {\n      switch (action.type) {\n        case 'UPDATE_SETTINGS':\n          const { payload } = action;\n          return { ...state, ...payload };\n        case 'UPDATE_PAIRS':\n          const pairsClone = { ...state.pairs };\n          const { updates } = action;\n          Object.keys(updates).forEach(updatedKey => {\n            // because REST API and WebSocket have different format\n            // we updating only prices\n            const { l, o, h, c, v } = updates[updatedKey];\n            if (typeof pairsClone[updatedKey] !== 'undefined') {\n              pairsClone[updatedKey].o = parseFloat(o);\n              pairsClone[updatedKey].h = parseFloat(h);\n              pairsClone[updatedKey].l = parseFloat(l);\n              pairsClone[updatedKey].c = parseFloat(c);\n              pairsClone[updatedKey].v = parseFloat(v);\n            } // else we don't use that cracked WS messages\n          })\n          // const pairs = { ...state.pairs, ...updates };\n          return { ...state, pairs: pairsClone};\n        default:\n          throw new Error(`Unhandled action: ${action.type}`);\n      }\n    },\n    initialState,\n    (state) => state,\n    'Binance'\n  );\n\n  return <Provider value={{ ...state, dispatch }}>{children}</Provider>;\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Pair } from './types';\n\nexport const pairChange = (pair: Pair): number =>\n  parseFloat((((pair.o - pair.c) / pair.o) * 100).toFixed(2));\n\nexport const keyBy = (array, key) =>\n  (array || []).reduce((r, x) => ({ ...r, [key ? x[key] : x]: x }), {});\n\nasync function jsonFetch(request: RequestInfo): Promise<any> {\n  try {\n    const response = await fetch(request);\n    const body = await response.json();\n    return body;\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nexport const getBinanceData = async (dispatch) => {\n  // Because API have CORS policy which doesn't include localhost\n  // I've mocked API sample\n  // const data = await getData('https://www.binance.com/exchange-api/v1/public/asset-service/product/get-products',{\n  const data = await jsonFetch('http://localhost:3003/binance');\n  const pairs = keyBy(data, 's');\n  //  сonst pairsOrder = data.map((item) => item.s);\n  dispatch({ type: 'UPDATE_SETTINGS', payload: { pairs } });\n};\n\nexport const connectWebSocket = (dispatch, url) => {\n  const ws = new WebSocket(url);\n\n  ws.onmessage = (evt: MessageEvent) => {\n    const { data } = JSON.parse(evt.data);\n    const updates = keyBy(data, 's');\n    dispatch({ type: 'UPDATE_PAIRS', updates });\n  };\n};\n","import memoize from 'fast-memoize';\nimport filter from 'lodash.filter';\nimport { PairAssocArray, Pair, TABS, SORT } from './types';\nimport { pairChange } from './utils';\n\nexport const filteredPairs = (\n  pairs: PairAssocArray,\n  tab: TABS,\n  search: string\n): Pair[] => {\n  const filtredArray = filter(pairs, (pair) => {\n    const tabСondition = pair.pm === tab;\n    const searchCondition =\n      pair.b.includes(search.toUpperCase()) ||\n      pair.q.includes(search.toUpperCase());\n    return tabСondition && searchCondition;\n  });\n  return filtredArray;\n};\n\nexport const filteredPairsSelector = memoize(filteredPairs);\n\nexport const sortedPairs = (filteredPairs: Pair[], sort: SORT): Pair[] => {\n  const clone = [...filteredPairs];\n  switch (sort) {\n    case 'PairASC': {\n      clone.sort((a, b) => (a.s.toUpperCase() > b.s.toUpperCase() ? 1 : -1));\n      break;\n    }\n    case 'PairDSC': {\n      clone.sort((a, b) => (a.s.toUpperCase() < b.s.toUpperCase() ? 1 : -1));\n      break;\n    }\n    case 'PriceASC': {\n      clone.sort((a, b) => (a.c > b.c ? 1 : -1));\n      break;\n    }\n    case 'PriceDSC': {\n      clone.sort((a, b) => (a.c < b.c ? 1 : -1));\n      break;\n    }\n    case 'ChangeASC': {\n      clone.sort((a,b) => (pairChange(a) > pairChange(b) ? 1 : -1));\n      break;\n    }\n    case 'ChangeDSC': {\n      clone.sort((a,b) => (pairChange(a) < pairChange(b) ? 1 : -1));\n      break;\n    }\n    case 'VolumeASC': {\n      clone.sort((a, b) => (a.v > b.v ? 1 : -1));\n      break;\n    }\n    case 'VolumeDSC': {\n      clone.sort((a, b) => (a.v < b.v ? 1 : -1));\n      break;\n    }\n    default:\n      // clone.sort((a, b) => (a.s.toUpperCase() > b.s.toUpperCase() ? 1 : -1));\n      break;\n  }\n  return clone;\n};\n\nexport const pairsSelector = memoize(sortedPairs);\n","import React from 'react';\n\nexport const star = (\n  <svg\n    xmlns='http://www.w3.org/2000/svg'\n    viewBox='0 0 24 24'\n    fill='currentColor'\n  >\n    <path\n      d='M21.4 10.8c-.3-1.1-.3-1.1-.7-2.1l-6-.1L12.8 3h-2.2l-2 5.6-5.9.1c-.3 1.1-.3 1.1-.7 2.1l4.8 3.6L5 20.1l1.8 1.3 4.9-3.4 4.9 3.4c.9-.7.9-.6 1.8-1.3l-1.8-5.7 4.8-3.6z'\n      fill='currentColor'\n    />\n  </svg>\n);\n\nexport const arrowsDefault = (\n  <svg\n    xmlns='http://www.w3.org/2000/svg'\n    viewBox='0 0 24 24'\n  >\n    <path\n      d='M9 10.368v-1.4L11.968 6l2.968 2.968v1.4H9zM14.936 13v1.4l-2.968 2.968L9 14.4V13h5.936z'\n      fill='#C1C6CD'\n    ></path>\n  </svg>\n);\n\nexport const arrowsAsc = (\n  <svg\n    xmlns='http://www.w3.org/2000/svg'\n    viewBox='0 0 24 24'\n    fill='none'\n  >\n    <path\n      opacity='0.5'\n      d='M16 12.85v1.65L12.75 18 9.5 14.5v-1.65H16z'\n      fill='#848E9C'\n    ></path>\n    <path\n      d='M9.5 9.745v-1.65l3.25-3.5 3.25 3.5v1.65H9.5z'\n      fill='url(#sorting-up-color-s24_svg__paint0_linear)'\n    ></path>\n    <defs>\n      <linearGradient\n        id='sorting-up-color-s24_svg__paint0_linear'\n        x1='16'\n        y1='4.594'\n        x2='9.5'\n        y2='4.594'\n        gradientUnits='userSpaceOnUse'\n      >\n        <stop stop-color='#EFB80B'></stop>\n        <stop offset='1' stop-color='#FBDA3C'></stop>\n      </linearGradient>\n    </defs>\n  </svg>\n);\n\nexport const arrowsDsc = (\n  <svg\n    xmlns='http://www.w3.org/2000/svg'\n    viewBox='0 0 24 24'\n    fill='none'\n  >\n    <path\n      opacity='0.5'\n      d='M9 10.153V8.5L12.25 5l3.25 3.501v1.652H9z'\n      fill='#848E9C'\n    ></path>\n    <path\n      d='M15.5 13.257v1.652l-3.25 3.5L9 14.91v-1.652h6.5z'\n      fill='url(#sorting-down-color-s24_svg__paint0_linear)'\n    ></path>\n    <defs>\n      <linearGradient\n        id='sorting-down-color-s24_svg__paint0_linear'\n        x1='9'\n        y1='18.41'\n        x2='15.5'\n        y2='18.41'\n        gradientUnits='userSpaceOnUse'\n      >\n        <stop stop-color='#EFB80B'></stop>\n        <stop offset='1' stop-color='#FBDA3C'></stop>\n      </linearGradient>\n    </defs>\n  </svg>\n);\n","import React, { useEffect, useContext } from 'react';\nimport { FixedSizeList as List } from 'react-window';\nimport { store } from './store.js';\n// import { ALTS, FIAT } from './contstans';\nimport { filteredPairsSelector, pairsSelector } from './selectors';\nimport { BinanceWidgetProps, SORT } from './types';\nimport { getBinanceData, connectWebSocket, pairChange } from './utils';\nimport { binanceWs } from './contstans';\nimport { star, arrowsDefault, arrowsAsc, arrowsDsc } from './icons';\nimport styles from './styles.module.css';\n\nconst Layout: React.FC<BinanceWidgetProps> = ({\n  title,\n  height,\n  width,\n  defaultTab,\n  defaultSort,\n  thirdCol\n}) => {\n  const context = useContext(store);\n  const { column, dispatch, pairs, search, sort, tab } = context;\n  const filteredPairs = filteredPairsSelector(pairs, tab, search);\n  const sortedPairs = pairsSelector(filteredPairs, sort);\n  // console.info(filteredPairs);\n\n  // Init API on start\n  useEffect(() => {\n    getBinanceData(dispatch);\n    connectWebSocket(dispatch, binanceWs);\n  }, []);\n\n  const updateValue = (name: string, val: string) =>\n    dispatch({ type: 'UPDATE_SETTINGS', payload: { [name]: val } });\n\n  const arrowIcon = (sort: SORT, type: string): JSX.Element => {\n    if (sort.includes(type)) {\n      if (sort.includes('ASC')) {\n        return arrowsAsc;\n      } else if (sort.includes('DSC')) {\n        return arrowsDsc;\n      }\n    }\n    return arrowsDefault;\n  };\n\n  const Row = ({ index, style }) => {\n    // const name = Object.keys(filteredPairs)[index];\n    const { b, q, c, o, v } = sortedPairs[index];\n\n    return (\n      <li style={style}>\n        <div>{`${b}/${q}`}</div>\n        <div>{c}</div>\n        <div>\n          {column === 'Change' ? `${pairChange(sortedPairs[index])}%` : v}\n        </div>\n      </li>\n    );\n  };\n\n  return (\n    <section\n      style={{\n        width: width ? `${width}px` : '313px',\n        height: height ? `${height}px` : '382px'\n      }}\n    >\n      <header>{title || 'Market'}</header>\n      <nav>\n        <button\n          className={tab === 'FAV' ? styles.active : ''}\n          onClick={() => updateValue('tab', 'FAV')}\n        >\n          {star}\n        </button>\n        <button>Margin</button>\n        <button\n          className={tab === 'BNB' ? styles.active : ''}\n          onClick={() => updateValue('tab', 'BNB')}\n        >\n          BNB\n        </button>\n        <button\n          className={tab === 'BTC' ? styles.active : ''}\n          onClick={() => updateValue('tab', 'BTC')}\n        >\n          BTC\n        </button>\n        {/* <select className={tab === 'ALTS' ? styles.active : ''}>\n          {ALTS.map((item: string) => (\n            <option key={item} value={item}>\n              {item}\n            </option>\n          ))}\n        </select> */}\n        <button\n          className={tab === 'ALTS' ? styles.active : ''}\n          onClick={() => updateValue('tab', 'ALTS')}\n        >\n          ALTS\n        </button>\n        {/* <select className={tab === 'USDⓈ' ? styles.active : ''}>\n          {FIAT.map((item: string) => (\n            <option key={item} value={item}>\n              {item}\n            </option>\n          ))}\n        </select> */}\n        <button\n          className={tab === 'USDⓈ' ? styles.active : ''}\n          onClick={() => updateValue('tab', 'USDⓈ')}\n        >\n          USDⓈ\n        </button>\n      </nav>\n      <aside>\n        <input\n          type='text'\n          placeholder='Search'\n          className={styles.search}\n          value={search}\n          onChange={(e) => updateValue('search', e.target.value)}\n        />\n        <input\n          type='radio'\n          name='thirdCol'\n          id='change'\n          value='change'\n          checked={column === 'Change'}\n          onChange={(e) => updateValue('column', 'Change')}\n        />\n        <label htmlFor='change'>Change</label>\n        <input\n          type='radio'\n          name='thirdCol'\n          id='volume'\n          value='volume'\n          checked={column === 'Volume'}\n          onChange={(e) => updateValue('column', 'Volume')}\n        />\n        <label htmlFor='volume'>Volume</label>\n      </aside>\n      <div className={styles.table}>\n        <header>\n          <a\n            href='#'\n            onClick={() =>\n              updateValue('sort', sort === 'PairASC' ? 'PairDSC' : 'PairASC')\n            }\n          >\n            Pair: {arrowIcon(sort, 'Pair')}\n          </a>\n          <a\n            href='#'\n            onClick={() =>\n              updateValue('sort', sort === 'PriceASC' ? 'PriceDSC' : 'PriceASC')\n            }\n          >\n            Last price: {arrowIcon(sort, 'Price')}\n          </a>\n          <a\n            href='#'\n            onClick={() =>\n              updateValue(\n                'sort',\n                sort === `${column}ASC`\n                  ? `${column}DSC`\n                  : `${column}ASC`\n              )\n            }\n          >\n            {`${column}:`} {arrowIcon(sort, column)}\n          </a>\n        </header>\n        <List\n          className='List'\n          height={200}\n          // itemCount={pairsOrder.length}\n          itemCount={sortedPairs.length}\n          itemSize={35}\n          width={width ? `${width}px` : '313px'}\n          innerElementType='ul'\n        >\n          {Row}\n        </List>\n      </div>\n    </section>\n  );\n};\n\nexport default Layout;\n","export const binanceWs = 'wss://stream.binance.com/stream?streams=!miniTicker@arr';\n\nexport const ALTS = ['All', 'ETH', 'XRP', 'TRX']\n\nexport const FIAT = [\n  'USDT',\n  'BUSD',\n  'TUSD',\n  'USDC',\n  'PAX',\n  'BKRW',\n  'EUR',\n  'IDRT',\n  'NGN',\n  'RUB',\n  'TRY',\n  'ZAR'\n];","import React from 'react';\nimport { StateInspector } from 'reinspect';\nimport { StateProvider } from './store.js';\nimport { BinanceWidgetProps } from './types';\n\nimport Layout from './Layout';\n\nconst BinanceWidget: React.FunctionComponent<BinanceWidgetProps> = (props) => (\n  <StateInspector>\n    <StateProvider>\n      <Layout {...props} />\n    </StateProvider>\n  </StateInspector>\n);\n\nexport default BinanceWidget;\n","import React from 'react';\n\nimport BinanceWidget from 'binance-cryptocurrency-widget';\nimport 'binance-cryptocurrency-widget/dist/index.css';\n\nconst App = () => {\n  return <BinanceWidget /* title='Create React Library Example 😄' */ />;\n};\n\nexport default App;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}